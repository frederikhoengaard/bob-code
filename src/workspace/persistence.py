import json
from datetime import datetime

from pydantic import BaseModel

from src.providers.models import Message
from src.workspace.config import WorkspaceConfig


class ConversationMetadata(BaseModel):
    """Metadata for a conversation"""

    started_at: str  # ISO timestamp
    last_message_at: str  # ISO timestamp
    message_count: int
    model: str
    title: str | None = None  # First 50 chars of first user message


class ConversationHistory(BaseModel):
    """Complete conversation data"""

    metadata: ConversationMetadata
    messages: list[Message]


class ConversationPersistence:
    """Handles conversation auto-save and loading"""

    def __init__(self, workspace_config: WorkspaceConfig):
        """
        Initialize conversation persistence.

        Args:
            workspace_config: WorkspaceConfig instance.
        """
        self.workspace_config = workspace_config

    def start_new_conversation(self, model: str) -> str:
        """
        Generate a new conversation filename.

        Args:
            model: LLM model name.

        Returns:
            Generated filename (without path).
        """
        return self._generate_filename()

    def save_conversation(self, filename: str, messages: list[Message], model: str) -> None:
        """
        Save conversation to file with updated metadata.

        Args:
            filename: Conversation filename (generated by start_new_conversation).
            messages: List of Message objects.
            model: Current model name.

        Raises:
            OSError: If unable to write file.
        """
        if not messages:
            # Don't save empty conversations
            return

        # Extract title from first user message
        title = self._extract_title(messages)

        # Find first and last message timestamps
        now = datetime.now().isoformat()
        started_at = now  # For new conversations
        last_message_at = now

        # If we're updating an existing conversation, try to preserve started_at
        filepath = self.workspace_config.get_conversations_dir() / filename
        if filepath.exists():
            try:
                with open(filepath) as f:
                    existing_data = json.load(f)
                started_at = existing_data.get("metadata", {}).get("started_at", started_at)
            except (json.JSONDecodeError, KeyError):
                pass  # Use default if existing file is corrupted

        # Create metadata
        metadata = ConversationMetadata(
            started_at=started_at,
            last_message_at=last_message_at,
            message_count=len(messages),
            model=model,
            title=title,
        )

        # Create conversation history
        conversation = ConversationHistory(metadata=metadata, messages=messages)

        # Write to file
        with open(filepath, "w") as f:
            json.dump(conversation.model_dump(), f, indent=2)

    def load_conversation(self, filename: str) -> ConversationHistory:
        """
        Load conversation from file.

        Args:
            filename: Conversation filename.

        Returns:
            ConversationHistory object.

        Raises:
            FileNotFoundError: If file doesn't exist.
            ValidationError: If JSON is malformed.
        """
        filepath = self.workspace_config.get_conversations_dir() / filename

        with open(filepath) as f:
            data = json.load(f)

        return ConversationHistory(**data)

    def list_conversations(self) -> list[tuple[str, ConversationMetadata]]:
        """
        List all conversations in workspace, sorted by date (newest first).

        Returns:
            List of (filename, metadata) tuples.
        """
        conversations_dir = self.workspace_config.get_conversations_dir()

        if not conversations_dir.exists():
            return []

        result = []
        for filepath in conversations_dir.glob("conversation_*.json"):
            try:
                with open(filepath) as f:
                    data = json.load(f)
                metadata = ConversationMetadata(**data.get("metadata", {}))
                result.append((filepath.name, metadata))
            except (json.JSONDecodeError, KeyError, ValueError):
                # Skip corrupted files
                continue

        # Sort by started_at descending (newest first)
        result.sort(key=lambda x: x[1].started_at, reverse=True)

        return result

    def _generate_filename(self) -> str:
        """
        Generate a timestamped filename for a new conversation.

        Returns:
            Filename in format conversation_YYYYMMDD_HHMMSS.json
        """
        return datetime.now().strftime("conversation_%Y%m%d_%H%M%S.json")

    def _extract_title(self, messages: list[Message]) -> str | None:
        """
        Extract title from first user message.

        Args:
            messages: List of Message objects.

        Returns:
            First 50 characters of first user message, or None if no user messages.
        """
        for message in messages:
            if message.role == "user":
                content = message.content.strip()
                if len(content) > 50:
                    return content[:47] + "..."
                return content

        return None
